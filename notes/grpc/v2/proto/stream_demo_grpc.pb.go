// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.7
// source: v2/proto/stream_demo.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// StreamDemoServiceClient is the client API for StreamDemoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StreamDemoServiceClient interface {
	// 客户端流模式：客户端发送多次请求，服务端响应一次
	InputStream(ctx context.Context, opts ...grpc.CallOption) (StreamDemoService_InputStreamClient, error)
	// 服务端流模式：客户端发送一个请求，服务端返回多次
	OutputStream(ctx context.Context, in *OutputStreamRequest, opts ...grpc.CallOption) (StreamDemoService_OutputStreamClient, error)
	// 服务端流模式：双向流，发送和接收同时进行，互不干扰
	BidirectionalStream(ctx context.Context, opts ...grpc.CallOption) (StreamDemoService_BidirectionalStreamClient, error)
}

type streamDemoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStreamDemoServiceClient(cc grpc.ClientConnInterface) StreamDemoServiceClient {
	return &streamDemoServiceClient{cc}
}

func (c *streamDemoServiceClient) InputStream(ctx context.Context, opts ...grpc.CallOption) (StreamDemoService_InputStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &StreamDemoService_ServiceDesc.Streams[0], "/stream_demo.v1.StreamDemoService/InputStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamDemoServiceInputStreamClient{stream}
	return x, nil
}

type StreamDemoService_InputStreamClient interface {
	Send(*InputStreamRequest) error
	CloseAndRecv() (*DataReply, error)
	grpc.ClientStream
}

type streamDemoServiceInputStreamClient struct {
	grpc.ClientStream
}

func (x *streamDemoServiceInputStreamClient) Send(m *InputStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamDemoServiceInputStreamClient) CloseAndRecv() (*DataReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(DataReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamDemoServiceClient) OutputStream(ctx context.Context, in *OutputStreamRequest, opts ...grpc.CallOption) (StreamDemoService_OutputStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &StreamDemoService_ServiceDesc.Streams[1], "/stream_demo.v1.StreamDemoService/OutputStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamDemoServiceOutputStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamDemoService_OutputStreamClient interface {
	Recv() (*DataReply, error)
	grpc.ClientStream
}

type streamDemoServiceOutputStreamClient struct {
	grpc.ClientStream
}

func (x *streamDemoServiceOutputStreamClient) Recv() (*DataReply, error) {
	m := new(DataReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamDemoServiceClient) BidirectionalStream(ctx context.Context, opts ...grpc.CallOption) (StreamDemoService_BidirectionalStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &StreamDemoService_ServiceDesc.Streams[2], "/stream_demo.v1.StreamDemoService/BidirectionalStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamDemoServiceBidirectionalStreamClient{stream}
	return x, nil
}

type StreamDemoService_BidirectionalStreamClient interface {
	Send(*BidirectionalStreamRequest) error
	Recv() (*DataReply, error)
	grpc.ClientStream
}

type streamDemoServiceBidirectionalStreamClient struct {
	grpc.ClientStream
}

func (x *streamDemoServiceBidirectionalStreamClient) Send(m *BidirectionalStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamDemoServiceBidirectionalStreamClient) Recv() (*DataReply, error) {
	m := new(DataReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamDemoServiceServer is the server API for StreamDemoService service.
// All implementations must embed UnimplementedStreamDemoServiceServer
// for forward compatibility
type StreamDemoServiceServer interface {
	// 客户端流模式：客户端发送多次请求，服务端响应一次
	InputStream(StreamDemoService_InputStreamServer) error
	// 服务端流模式：客户端发送一个请求，服务端返回多次
	OutputStream(*OutputStreamRequest, StreamDemoService_OutputStreamServer) error
	// 服务端流模式：双向流，发送和接收同时进行，互不干扰
	BidirectionalStream(StreamDemoService_BidirectionalStreamServer) error
	mustEmbedUnimplementedStreamDemoServiceServer()
}

// UnimplementedStreamDemoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedStreamDemoServiceServer struct {
}

func (UnimplementedStreamDemoServiceServer) InputStream(StreamDemoService_InputStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method InputStream not implemented")
}
func (UnimplementedStreamDemoServiceServer) OutputStream(*OutputStreamRequest, StreamDemoService_OutputStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method OutputStream not implemented")
}
func (UnimplementedStreamDemoServiceServer) BidirectionalStream(StreamDemoService_BidirectionalStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method BidirectionalStream not implemented")
}
func (UnimplementedStreamDemoServiceServer) mustEmbedUnimplementedStreamDemoServiceServer() {}

// UnsafeStreamDemoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StreamDemoServiceServer will
// result in compilation errors.
type UnsafeStreamDemoServiceServer interface {
	mustEmbedUnimplementedStreamDemoServiceServer()
}

func RegisterStreamDemoServiceServer(s grpc.ServiceRegistrar, srv StreamDemoServiceServer) {
	s.RegisterService(&StreamDemoService_ServiceDesc, srv)
}

func _StreamDemoService_InputStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamDemoServiceServer).InputStream(&streamDemoServiceInputStreamServer{stream})
}

type StreamDemoService_InputStreamServer interface {
	SendAndClose(*DataReply) error
	Recv() (*InputStreamRequest, error)
	grpc.ServerStream
}

type streamDemoServiceInputStreamServer struct {
	grpc.ServerStream
}

func (x *streamDemoServiceInputStreamServer) SendAndClose(m *DataReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamDemoServiceInputStreamServer) Recv() (*InputStreamRequest, error) {
	m := new(InputStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _StreamDemoService_OutputStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OutputStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamDemoServiceServer).OutputStream(m, &streamDemoServiceOutputStreamServer{stream})
}

type StreamDemoService_OutputStreamServer interface {
	Send(*DataReply) error
	grpc.ServerStream
}

type streamDemoServiceOutputStreamServer struct {
	grpc.ServerStream
}

func (x *streamDemoServiceOutputStreamServer) Send(m *DataReply) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamDemoService_BidirectionalStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamDemoServiceServer).BidirectionalStream(&streamDemoServiceBidirectionalStreamServer{stream})
}

type StreamDemoService_BidirectionalStreamServer interface {
	Send(*DataReply) error
	Recv() (*BidirectionalStreamRequest, error)
	grpc.ServerStream
}

type streamDemoServiceBidirectionalStreamServer struct {
	grpc.ServerStream
}

func (x *streamDemoServiceBidirectionalStreamServer) Send(m *DataReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamDemoServiceBidirectionalStreamServer) Recv() (*BidirectionalStreamRequest, error) {
	m := new(BidirectionalStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamDemoService_ServiceDesc is the grpc.ServiceDesc for StreamDemoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StreamDemoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "stream_demo.v1.StreamDemoService",
	HandlerType: (*StreamDemoServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InputStream",
			Handler:       _StreamDemoService_InputStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "OutputStream",
			Handler:       _StreamDemoService_OutputStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BidirectionalStream",
			Handler:       _StreamDemoService_BidirectionalStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "v2/proto/stream_demo.proto",
}
