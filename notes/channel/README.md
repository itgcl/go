# goroutine & channel使用

https://go101.org/article/channel-closing.html

整理一下实际开发中使用goroutine和channel的场景，归类为以下四种场景。

1. 一个发送者和一个接收者
2. 一个发送者和多个接收者
3. 多个发送者和一个接收者
4. 多个发送者和多个接收者

## 一个发送者和一个接收者
查看v1目录example方法。

v2目录example方法实现了复杂的1对1关系。

## 一个发送者和多个接收者
查看v3。

## 多个发送者和一个接收者
> 暂时想不到多发送者和一个生产者模型的应用场景。

**多发送者不能直接关闭channel，会导致其他发送者向关闭的channel发送数据引发panic。**

### 大致分为2种实现方式

1. 引入一个额外的channel，唯一接收者通过关闭一个额外的信号通道，实现通知发送者停止发送。
2. 使用sync.waitGroup包，等待多个发送者都结束了，关闭channel。

查看v4。

## 多个发送者和多个接收者

实现方式：增加一个接收退出信号的channel和一个实际关闭的channel。
然后通过引入一个裁判员携程，接收退出信号，然后对实际要关闭的channel进行关闭。
发送者和接收者每次发送或者接收数据时，检查实际要关闭的channel是否被关闭。

查看v5。不能在发送方或者接收方直接关闭channel，否则会上面多发送者一样。

